# This script was originally created on 2023/10/19 to support renaming a
# significant number of MKV files (Daniel Tiger's Neighborhood), whose filenames
# were incorrect, but they did have the title of the episode in them.

# Based on this this tool was written to take a bad name sourceFile.csv, in the
# format (FileName,Title), that would be generated by Get-TitleFromMKV.ps1. The
# tool would then take an input episodeTitles.csv which was in the format of
# (Season,Episode,Title 1,Title 2), it would then use this information to
# attempt to identify the correct Season and Episode Number. The generation of
# the episodeTitles.csv was left outside of automation, but basically I pulled
# the titles from Wikipedia into Excel and then extracted the titles using some
# creative Excel sheet references and then extending the set.

# This particular set of files was interesting because also in some cases the
# MKV did not contain Title information. To account for this hacks were put in
# place to parse the file name because the files would also have the name in it.
# For example one of the file names was `Daniel Tiger_s
# Neighborhood_S07E05_Daniel Makes a Noise Maker_Daniel Makes the Neighborhood`.

# Daniel Tiger is a kids show that runs for approxmiately 30 minutes and
# generally has a "double feature", resulting in both a Title 1 and Title 2.
# Because of this the logic below is written to attempt to lookup the title for
# either of the two, and then assign an episode number. This was done because in
# some cases the first title was either incorrect in some way (mispelled
# usually), or contained puncuation that was not in the Wikipedia title. In
# addition sometimes there were unprintable characters, specifically the ' used
# some weird Unicode version that looked similar but was parsed poorly (as
# `γçö` or `’`) much of this is error handling to support this.

$sourceFiles = Import-Csv $PSScriptRoot\BadNames.csv
$episodeTitles = Import-Csv $PSScriptRoot\DanielTigerEpisodes.csv

$mkvPropEdit = 'C:\DevApps\System\mkvtoolnix\mkvpropedit.exe'

# This is only required if attempting to edit MP4 metadata
$windowsAPICodePackShellDll = "$PSScriptRoot\Microsoft.WindowsAPICodePack.Shell.dll"

if (Test-Path $windowsAPICodePackShellDll) {
    Add-Type -Path $windowsAPICodePackShellDll
}

# Have an Episode Title Lookup For When we Retitle This
[System.Collections.Generic.Dictionary[string, string]]$episodeTitleLookup = [System.Collections.Generic.Dictionary[string, string]]::new()

# Load this into a lookup dictionary
[System.Collections.Generic.Dictionary[string, string]]$lookupDictionary = [System.Collections.Generic.Dictionary[string, string]]::new()
foreach ($episodeTitle in $episodeTitles) {
    $episodeNumber = "S$($($episodeTitle.Season).PadLeft(2,'0'))E$($($episodeTitle.Episode).PadLeft(2,'0'))"
    $episodeCombinedTitle = $($episodeTitle.'Title 1')
    $episode1Title = $($episodeTitle.'Title 1').ToLower().Replace("'", [string]::Empty)
    $episode2Title = $($episodeTitle.'Title 2').ToLower().Replace("'", [string]::Empty)
    $lookupDictionary.Add($episode1Title, $episodeNumber)
    if (-Not([string]::IsNullOrWhiteSpace($episode2Title))) {
        $lookupDictionary.Add($episode2Title, $episodeNumber)
        $episodeCombinedTitle = "$episodeCombinedTitle / $($episodeTitle.'Title 2')"
    }
    $episodeTitleLookup.Add($episodeNumber, $episodeCombinedTitle)
}

$results = foreach ($sourceFile in $sourceFiles) {

    if ($sourceFile.Title.Contains('/')) {
        $titles = $sourceFile.Title.Split('/')
    }
    else {
        $titles = $sourceFile.Title.Split('   ')
    }

    $matchFound = $false
    foreach ($title in $titles) {
        $title = $title.ToLower().Trim().Replace("'", [string]::Empty).Replace("γçö", [string]::Empty).Replace("’", [string]::Empty)
        if ($lookupDictionary.ContainsKey($title)) {
            $episodeNumber = $lookupDictionary[$title]
            Write-Host "Match Found! [$($sourceFile.FileName)] Maps to [$episodeNumber]"
            [PSCustomObject]@{
                FileName      = $sourceFile.FileName
                EpisodeNumber = $episodeNumber
            }
            $matchFound = $true
            break
        }
        else {
            Write-Verbose "Had to look at the second title"
        }
    }

    if (-Not($matchFound)) {
        Write-Warning "Unable to map [$($sourceFile.FileName)] to any known episodes."
    }
}

foreach ($renameOperation in $results) {
    $episodeTitle = $episodeTitleLookup[$renameOperation.EpisodeNumber]
    $fileSystemSafeName = $episodeTitle.Replace(' / ', '_').Replace(' ', '.').Replace('!', [string]::Empty).Replace("'", [string]::Empty)
    foreach ($c in [System.IO.Path]::GetInvalidFileNameChars()) {
        if ($fileSystemSafeName.Contains($c)) {
            Write-Error "Filename [$fileSystemSafeName] was not safe! Contains [$c] Aborting."
        }
    }

    $sourceFileExtension = [System.IO.Path]::GetExtension($renameOperation.FileName)
    if ($sourceFileExtension -eq ".mkv") {
        if (-Not(Test-Path $mkvPropEdit)) {
            Write-Error "Unable to locake mkvpropedit at [$mkvPropEdit]. Aborting."
        }
    }
    elseif ($sourceFileExtension -eq '.mp4') {
        if (-Not(Test-Path $windowsAPICodePackShellDll)) {
            Write-Error "Unable to locake WindowsAPICodePack.Shell at [$windowsAPICodePackShellDll]. Aborting."
        }
    }


    $newFileName = "Daniel.Tigers.Neighborhood.$($renameOperation.EpisodeNumber).$fileSystemSafeName$sourceFileExtension"
    $newFileNamePath = [System.IO.Path]::Combine($([System.IO.Path]::GetDirectoryName($renameOperation.FileName)), $newFileName)

    $newFileNamePath
    Move-Item -Path $renameOperation.FileName -Destination $newFileNamePath
    if ($sourceFileExtension -eq '.mkv') {
        &$mkvPropEdit $newFileNamePath --edit info --set "title=$episodeTitle"
    }
    elseif ($sourceFileExtension -eq '.mp4') {
        # There really doesn't seem to be a way to do this within PowerShell;
        # See this guy [0]. I think the key is to use something like they do in
        # C# using the Windows API Code pack [1] If you look at the underlying
        # code[2] he'll eventually call down into IShellItem2::GetPropertyStore
        # [3] and then call IPropertyStore::SetValue [4], however these are the
        # C++ API's which do not appear to be exposed via COM, which means there
        # is no straight forward way within PowerShell to accomplish this.
        #
        # [0]-https://stackoverflow.com/questions/65228096/powershell-changing-mp4-metadata-right-click-properties
        # [1]-https://stackoverflow.com/questions/24040248/is-it-possible-to-set-edit-a-file-extended-properties-with-windows-api-code-pack
        # [2]-https://github.com/aybe/Windows-API-Code-Pack-1.1/blob/master/source/WindowsAPICodePack/Shell/PropertySystem/ShellPropertyWriter.cs
        # [3]-https://learn.microsoft.com/en-us/windows/win32/api/shobjidl_core/nf-shobjidl_core-ishellitem2-getpropertystore
        # [4]-https://learn.microsoft.com/en-us/windows/win32/api/propsys/nf-propsys-ipropertystore-setvalue
        $shellFile = [Microsoft.WindowsAPICodePack.Shell.ShellFile]::FromFilePath($newFileNamePath)
        $propertyWriter = $shellFile.Properties.GetPropertyWriter()
        # Ideally we'd use
        # `Microsoft.WindowsAPICodePack.Shell.PropertySystem.SystemProperties.System.Title`
        # but for some reason I was unable to load this static type?
        $titlePropertyKey = [Microsoft.WindowsAPICodePack.Shell.PropertySystem.PropertyKey]::new([Guid]::new("{F29F85E0-4FF9-1068-AB91-08002B27B3D9}"), 2)
        $propertyWriter.WriteProperty($titlePropertyKey, $episodeTitle)
        $propertyWriter.Close()
    }
}
